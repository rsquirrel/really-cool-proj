\documentclass[12pt,psfig,a4]{article}
\usepackage{geometry}
%\geometry{a4paper}
\geometry{left=28mm,right=28mm,top=21mm,bottom=21mm}

%\gemoetry{verbose,a4paper,tmargin=21mm,bmargin=21mm,lmargin=18mm,rmargin=18mm}
\usepackage{graphics}
\usepackage{setspace}
\newcommand{\Lyx}{L\kern-.1667em\lower.25em\hbox{y}\kern-.125emX\spacefactor1000}
\newcommand\bibname{References}
\singlespacing
\begin{document}
\bibliographystyle{plain} 
\pagestyle{plain} 
\pagenumbering{arabic}
%\rmfamily

\newenvironment{code}
{\sffamily
 \setlength{\parskip}{0pt}
 \noindent}
{}

\title{TML: Language Reference Manual}
\author{
Jiabin Hu (jh3240)\\
Akash Sharma (as4122)\\
Shuai Sun (ss4088)\\
Yan Zou (yz2437)
}
\date{\today}
\maketitle

% Article starts here

%\begin{abstract} 

%\end{abstract} 

%{\bf Keywords:} \\

\section{Introduction}

\textit{This section will be written later.}

\section{Lexical Conventions}

\subsection{Character Set}
TML takes the standard \textbf{ASCII} character set for source codes.

\subsection{Comments}
In TML, there are two ways to make comments. The first style starts with the characters \textbf{/*}, and ends with the characters \textbf{*/}, all contents between which are comments. Note that, just like C-style comments, TML supports only un-nested comments. The second style is inline comments. It starts with the characters \textbf{//}, all contents in the current line after which are regarded as comments.

\subsection{Identifiers}
In TML, an identifier is a string that starts with a letter or an underscore, and consists of a sequece of letters, digits, and underscores. The max length of an identifier is 26 characters. 
All identifiers are case-sensitive in TML.

\subsection{Keywords}
\textit{This section needs discussion.}\\
In TML, the words listed in Table~\ref{keywords} are reserved as keywords, and are not allowed to be used as a user-defined identifier.

\begin{table}[ht]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
if & else & type & while & foreach \\
\hline
in & by & do & print &\\
\hline
preorder & inorder & postorder & border &\\
\hline
int & float & char & string & bool  \\
\hline
treetype &  & & & \\
\hline
\end{tabular}
\caption{Keywords in TML}
\label{keywords}
\end {center}
\end{table}

%\subsection{Operators}
%\textit{This section needs discussion.}\\
%TML provides basic operators for arithmetic, comparing, assignment and string operations, which are listed in Table~\ref{basic_operators}.
%
%\begin{table}[ht]
%\begin{center}
%\begin{tabular}{| c | c |}
%\hline
%\textbf{Usage} & \textbf{Operator} \\
%\hline
%Arithmetic & +, -, *, /, \% \\
%\hline
%Comparing & \textgreater, \textgreater=, ==, !=, \textless=, \textless \\
%\hline
%Assignment & =, +=, -=, *=, /=, \%= \\
%\hline
%Sting & ==, sizeof() \\
%\hline
%\end{tabular}
%\caption{Basic Operators in TML}
%\label{basic_operators}
%\end {center}
%\end{table}



\section{Expressions}
In TML, expressions consists of operators and their operands. In this section, we'll begin with defining each operator. After this, we'll define the precedence rules so that the evaluation can be carried out unambigously.

\subsection{Arithmetic Operators}
In TML, arithmetic operators are $+$, $-$, $*$, $/$ and $\%$. $+$ means addition, $-$ means substruction, $*$ means multiplication, $/$ means division and $\%$ means modulation. All of them are binary and left associative. It requires that their operands must be of the same primitive types, and the result will be of the same type.

\subsection{Comparative Operators}
In TML, comparative operators are $>$ (greater than), $<$ (less than), $>=$ (greater than or equal to), $<=$ (less than or equal to), $!=$ (not equal) and $==$ (equal). All of them are binary and left associative. It requires that their operands must be of the same primitive types . The result will be of type bool.

\subsection{Logical Operators}
Logical operators in TML include \&\& (logical and), $||$ (logical or) and ! (logical not). \&\& and $||$ are binary and left-associative. They take two operands of type bool, and return a bool value. ! is unary and appears on the left side of the operand. They type of the operand must be bool and the return type is also bool.

\subsection{Assignment Operators}
TML's assignment operator is =. it's binary and right-associative. The left operand must be an identifier and the right operand must be an expression. It assigns the value of the expression to the identifier, and returns the value of the identifier. This allows chained assignment. In addition, the following short-cut assignment operators are also defined: +=, -=, *=, /=, \%=. They require the expression and identifier of the same type.

\subsection{Parentheses}
In TML, parentheses in expressions are used to overwrite the precedence rules, Expression enclosed by the parentheses will always be calculated first before applying its adjacent operators.

\subsection{Tree Operators}
The highlight of TML is a set of operators that can be applied to trees. They are divided into three categories: tree-building, tree-copying and tree-querying.

\subsubsection{Tree-building operator}
We define $->$ to be the tree building operator. It's binary and right-associative. The left operand is a single tree node, representing the root. The right operand is a list of trees, enclosed by parentheses and seperated by commas, representing the immediate children of the root. For example, a$->$(b, c) means building a tree with a as root and b as its left subtree, and c as its right subtree. This operator returns the newly built tree.

\subsubsection{Tree-copying operators}
We define two operators to copy trees. @ means copying the node and its value only, with all of its children set to null. \$ means creating a new tree, with exactly the same stucture as the original tree. Both of them are unary and appear on the left side of the opearand. They return the new tree.

\subsubsection{Tree-querying operators}
In TML, we define operator \# as follows: \#n means the order of node n among its siblings, starting from 0. For example, if node a has three nodes b, c, d, then \#b, \#c, \#d will return 0, 1, 2, respectively. If n has no parent, \#n will return null.

\subsection{Precedence Rules}
\begin{table}[ht]
\begin{center}
\begin{tabular}{| c | c |}
\hline
1 & () \\
2 & \# \\
3 & @, \$ \\
4 & *, /, \% \\
5 & +, - \\
6 & $<$, $>$, $<=$, $>=$, $!=$, $==$ \\
7 & ! \\
8 & \&\& \\
9 & $||$ \\
10 & =, +=, -=, *=, /=, \%= \\
11 & $->$ \\
\hline
\end{tabular}
\caption{Precedence Rules}
\label{keywords}
\end {center}
\end{table}

\section{Statements}

<<<<<<< .mine
\subsection{Variable Declaration and Initialization Statement}

\subsubsection{Type Specifiers}

\subsubsection{Declarators}

\subsection{Expression Statements}
The expression statement is the most common one in TML. It consists of an expression and a semicolon at the end. Any expression can be used here. TML will evaluate the expression and ignore the final evaluation result.

\begin{code}
	\textit{expression};
\end{code}

\subsection{Compound Statements}
The compound statement is a list of statements surrounded by curly braces.

\begin{code}
\{ \textit{statement-list}
%\\
%statement
%statement
%...
%\\
\}
\end{code}

\noindent
The \textit{statement-list} consists of sequential statements one after another

\begin{code}
\textit{statement-list}  $\rightarrow$ \textit{statement} $\mid$ \textit{statement} \textit{statement-list}
\end{code}

\subsection{Conditional Statements}
The conditional statements contain only the if statement with the following syntax (The square brackets means optional):

\begin{code}
if (\textit{expression}) \textit{statement} [else \textit{statement}]
\end{code}

\noindent
If compound statements are used for both statements, as is used mostly, the if statement can be written as follows:

\begin{code}
if (\textit{expression}) \\
\{ \\
\textit{statement} \\
... \\
\} \\
else ...
\end{code}

\subsection{Iterative Statements}
There are four kinds of iterative statements: while statement, do statement, for statement and foreach statement.

\subsubsection{while statement}
The while statement contains a condition-expression and a loop body. The codes in the loop body will be executed again and again as long as the evaluation result of the condition-expression is true. The condition-expression will be evaluated before each time the loop body is executed. This statement has the following syntax:

\begin{code}
while (\textit{expression}) \textit{statement}
\end{code}

\subsubsection{do statement}
Similar to the while statement, the do statement also contains a condition-expression and a loop body. The codes in the loop body will be executed again and again as long as the evaluation result of the condition-expression is true. But the condition-expression will be evaluated after each time the loop body is executed. This statement has the following syntax:

\begin{code}
\begin{tabbing}
do \= \\
\> \textit{statement} \\
while (\textit{expression})
\end{tabbing}
\end{code}

\subsubsection{for statement}
The for statement takes three expressions: init-expression, cond-expression and loop-expression. At the beginning, the init-expression will be evaluated. And then, the cond-expresion is evaluated repeatedly until the result is false. For each time the evaluation has the result true, the codes of the loop body will be executed and the loop-expression will be evaluated afterwards. It has the following syntax:

\begin{code}
for (\textit{init-expression}; \textit{cond-expression}; \textit{loop-expression}) \\
\textit{statement}
\end{code}

\subsubsection{foreach statement}
The foreach statement is used to enumerate the elements contained in an object, like all the characters in a string, all subtrees in a tree, and so on. It is mainly operated on trees. The syntax of this statement is:

\begin{code}
foreach \textit{variable1} in \textit{variable2} [by \textit{function}] do \\
\textit{statement}
\end{code}

\noindent
This statement will enumerate all the elements contained in variable2, and for each of the elements, it will store the element into variable1 and execute the loop body once. The order of the elements in each iteration will be determined by the function defined. There are four existing functions named preorder, inorder, postorder and levelorder, which are used to traverse the tree in corresponding order. If the function is not given, preorder will be used as default.

\subsection{Other Statements}
There are other statements that we may use in special conditions.

\subsubsection{break statements}
This statement is simply written as:

\begin{code}
break;
\end{code}

\noindent
It is used to immediately terminate a loop and execute the codes following the loop.

\subsubsection{continue statements}
This statement is simply written as:

\begin{code}
continue;
\end{code}

\noindent
It is used to immediately enter the next iteration of the loop ignoring the left of the codes in this iteration.

\subsubsection{return statements}
This statement is simply written as:

\begin{code}
return[ expression];
\end{code}

\noindent
It is used to immediately exit a function and take expression as the return value of the function. The expression is optional as some functions do not have a return value.

\subsubsection{NULL statements}
This statement is simply written as:

\begin{code}
;
\end{code}

\noindent
It does nothing.


\section{Functions}

\section{Scope}

\section{Language Restrictions}

\section{Language Formalization}

\section{Conversions to Java}





%\begin{thebibliography}{}

%\end{thebibliography}   

\end{document}
