\documentclass[12pt,psfig,a4]{article}
\usepackage{geometry}
%\geometry{a4paper}
\geometry{left=28mm,right=28mm,top=21mm,bottom=21mm}

%\gemoetry{verbose,a4paper,tmargin=21mm,bmargin=21mm,lmargin=18mm,rmargin=18mm}
\usepackage{graphics}
\usepackage{setspace}
\newcommand{\Lyx}{L\kern-.1667em\lower.25em\hbox{y}\kern-.125emX\spacefactor1000}
\newcommand\bibname{References}
\singlespacing
%\setlength{\parskip}{0pt}
%\setlength{\parsep}{0pt}
%\setlength{\headsep}{0pt}
%\setlength{\topskip}{0pt}
%\setlength{\topmargin}{0pt}
%\setlength{\topsep}{0pt}
%\setlength{\partopsep}{0pt}
\usepackage[compact]{titlesec}
\titlespacing{\section}{0pt}{*1}{*1}
\titlespacing{\subsection}{0pt}{*1}{*1}
\titlespacing{\subsubsection}{0pt}{*1}{*1}

\begin{document}
\bibliographystyle{plain} 
\pagestyle{plain} 
\pagenumbering{arabic}
%\rmfamily
\newenvironment{code}
{\sffamily
 \setlength{\parskip}{0pt}
}
{}


\title{TML: Language Reference Manual}
\author{
Jiabin Hu (jh3240)\\
Akash Sharma (as4122)\\
Shuai Sun (ss4088)\\
Yan Zou (yz2437)
}
\date{\today}
\maketitle

% Article starts here

%\begin{abstract} 

%\end{abstract} 

%{\bf Keywords:} \\

\section{Introduction}

Tree manipulation language (TML) is user friendly language that is designed to help users program trees. It allows users to create, manipulate and run algorithms on trees. Various existing programming languages make tree operations cumbersome and TML is intended to bridge this gap. In TML everything is of type Tree except primitive data types. Each node of the tree is of type Tree and it has fields associated with it like parent, child etc. Every node of the Tree is root for its subtree. Nodes of the tree can consist of user defined or primitive value types and they can be of any degree. We can refer to any child or parent node of a given node using predefined constructs. TML provides methods to perform trivial operations on trees such as tree traversal, node creation or deletion etc.
%\textit{This section will be written later.}

\section{Lexical Conventions} \label{lexCon}
There are different classes of tokens that are supported in TML. Token types are identifiers, keywords, literals, Strings and operators. As in c, whitespace characters are ignored except insofar as they serve to delineate other tokens in the input stream. If the input stream has been parsed into tokens up to a given character,the next token is taken to include the longest string of characters which could possibly constitute a token.

%Akash: try to reorganize the sentences

\subsection{Character Set}
TML takes the standard \textbf{ASCII} character set for source codes.

\subsection{Comments}
In TML, there are two ways to make comments. The first style starts with the characters \textbf{/*}, and ends with the characters \textbf{*/}, all contents between which are comments. Note that, just like C-style comments, TML supports only un-nested comments. The second style is inline comments. It starts with the characters \textbf{//}, all contents in the current line after which are regarded as comments.

\subsection{Identifiers} \label{lexConId}
In TML, an identifier is a string that starts with a letter or an underscore, and consists of a sequece of letters, digits, and underscores. %The max length of an identifier is 26 characters. 
All identifiers are case-sensitive in TML.

\subsection{Keywords}
%\textit{This section needs discussion.}\\
In TML, the words listed in Table~\ref{keywords} are reserved as keywords, and are not allowed to be used as a user-defined identifier.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
if & else & type & while & foreach \\
\hline
in & by & return & & do\\  %%whether remove the keyword do??
\hline
preorder & inorder & postorder & levelorder &\\
\hline
int & float & char & string & bool  \\
\hline
treetype & void & & & \\
\hline
\end{tabular}
\caption{Keywords in TML}
\label{keywords}
\end {center}
\end{table}

%\subsection{Operators}
%\textit{This section needs discussion.}\\
%TML provides basic operators for arithmetic, comparing, assignment and string operations, which are listed in Table~\ref{basic_operators}.
%
%\begin{table}[ht]
%\begin{center}
%\begin{tabular}{| c | c |}
%\hline
%\textbf{Usage} & \textbf{Operator} \\
%\hline
%Arithmetic & +, -, *, /, \% \\
%\hline
%Comparing & \textgreater, \textgreater=, ==, !=, \textless=, \textless \\
%\hline
%Assignment & =, +=, -=, *=, /=, \%= \\
%\hline
%String & ==, sizeof() \\
%\hline
%\end{tabular}
%\caption{Basic Operators in TML}
%\label{basic_operators}
%\end {center}
%\end{table}


% Shuai Begin
\subsection {Constants}
There are several kinds of constants in TML, which are listed as follows.
\subsubsection {Integer constants}
An integer constant consists of a sequence of digits, starting with a non-zero digit. All integer constants are considered to be decimal and of type integer.

\subsubsection {Float constants}
A floating constant consists of an integer par, a decimal point, a fraction part, and optionally an E with a signed integer exponent. The integer and fraction parts both consist of a sequence of digits, and either one could be missing, but not both. Either the decimal point or the E with the exponent could be missing, but not both. All floating constants are of type float.

\subsubsection {Character constants}
A character constant is one ASCII character enclosed by $'$ $'$, which is of character type. Note that $'$\textbackslash$n'$, $'$\textbackslash$t'$, $'$\textbackslash$r'$, etc. are character constants.

\subsubsection {String constants}
A string constant consists of several character constants enclosed by $"$ $"$, and implicitly ends with $'$\textbackslash$0'$.

\subsubsection {Boolean constants}
There are only two Boolean constants, true and false.

\subsubsection {Tree constant}
There is only one tree constant, which is the null constant. The null constant is a null value of any tree type. If a tree is null, then it means the tree reference is lost at the point of time. In TML, the null constant is written as a tilda.


\section {Types}
In TML, there are two kind of types, the \textit{primitive types} and the \textit{tree types}.

\subsection {Primitive Types}
There are several kinds of primitive types as listed below in Table~\ref{pri_types}. 

\begin{table}[!ht]
\begin{center}
\begin{tabular}{| c | c | c |}
\hline
\textbf{Primitive Type} & \textbf{Size} & \textbf{Range} \\
\hline
Integer & 4 bytes & -2 147 483 648 ~  2 147 483 647 \\
\hline
Float & 4 bytes & about $\pm$3.402 823 47E+38\\
\hline
Character & 2 byte &  ASCII\\  % check the java and boolean
\hline
String & $\geq$ 1 byte & combinations of characters \\
\hline
Boolean & 4 byte & true, false \\
\hline
\end{tabular}
\caption{Primitive Types in TML}
\label{pri_types}
\end {center}
\end{table}

\subsubsection {Intergers}
In TML, there is only one type of integer. The integers are signed, and are of fixed size. The size of an integer is four bytes.

\subsubsection {Floats}
In TML, there is only one type of floating point number. The size of the float type is four bytes.

\subsubsection {Characters}
In TML, there is only one type of character. The size of a character is two bytes. The characters are interpreted as ASCII code.

\subsubsection {Strings}
Strings are considered as a primitive type in TML. A string is a permutation of more than one characters. A string can be compared with another string. The size of a string equals to the number of characters in it.

\subsubsection {Booleans}
Boolean type is a primitive type in TML. There are only two values, true and false, in the Boolean type, which is used to determinate logic conditions. There is no conversions between integers and these two values.

\subsection {Tree Types}
In TML, a \textit{tree type} is a type to represent trees. By using the tree types, users can define and use tree data structures in their programs.

In a tree data structure, children of the root node can be also regarded as roots of sub trees. By this concept, in TML, all nodes in a tree are of the same tree type with the root. There is no tree node type in TML.

\subsubsection {Define a tree type}
Tree types are defined by users before they can declare and define variables of the tree types. A tree type consists of necessary parts, \textit{type name}, \textit{degree} and \textit{member variable(s)}, and an optional part, \textit{children index aliases}. To define a tree type, the \textit{type name}, \textit{degree} and \textit{member variable(s)} must be defined, and the \textit{children index aliases} can be optionally defiined. The size of a tree type is the sum size of its member variable types.

An example of a tree type definition, MyTree\_t, is given below.

\begin{code}
\begin{tabbing}
treetype \textless2, [left, right]\textgreater MyTree\_t \\
\{\\
~~~~int i;\\
~~~~float f;\\
~~~~string s;\\
\}
\end{tabbing}
\end{code}


\subsubsection {Type name}
The \textit{type name} of a tree type follows the identifier definition in the section~\ref{lexConId}. After the tree type is defined, the type name can be used to define variables of this type.

\subsubsection {Degree}
In TML, each tree type must define a fixed \textit{degree} at definition. All nodes of the same tree type have the same degree. The value range of the degree is from 1 to 99. The degree of a tree type can be referred to by using  ????????????????????????? introduced in the section~\ref{treeOp}.

% use &a  to get the degree

\subsubsection {Member variables}
In TML, a tree type can define its own \textit{member variable(s)} to store values for algorithms and programs. Each tree type can have at most 99 member variables. Each member variable must have a name which is unique in its tree type, and can be of any primitive types or tree types. Note that if a member variable is defined as some tree type, the definition of the tree type must appear before the member variable definition. All member variables are public. The member variables of a tree type variable can be referred to by using  ????????????????????? operation introduced in the section~\ref{treeOp}.

% limit the member tree varible have only primitive types

\subsubsection {Children index and aliases}
In TML, children sub roots of a root can be referred to by the index number, ranging from 0 to degree-1. Optionally, at the definition of a tree type, user can define alias of the children indices. The alias follows the identifier definition in section~\ref{lexConId}. Note that if aliases are defined, then aliases for all Children indices must be defined. Only defining a subset of children indices is not allowed in TML. Whether using number indices or aliases, the children of a tree root can be referred to by using ???????????????????????? introduced in section~\ref{treeOp}.

\subsection {Type Conversions}
In TML, no type conversion is allowed.

% Shuai End

\section{Expressions}
In TML, expressions consists of operators and their operands. In this section, we'll begin with defining each operator. After this, we'll define the precedence rules so that the evaluation can be carried out unambigously.

\subsection{Arithmetic Operators}
In TML, arithmetic operators are $+$, $-$, $*$, $/$ and $\%$. $+$ means addition, $-$ means substruction, $*$ means multiplication, $/$ means division and $\%$ means modulation. All of them are binary and left associative. It requires that their operands must be of the same primitive types, and the result will be of the same type.

\subsection{Comparative Operators}
In TML, comparative operators are $>$ (greater than), $<$ (less than), $>=$ (greater than or equal to), $<=$ (less than or equal to), $!=$ (not equal) and $==$ (equal). All of them are binary and left associative. It requires that their operands must be of the same primitive types . The result will be of type bool.

\subsection{Logical Operators}
Logical operators in TML include \&\& (logical and), $||$ (logical or) and ! (logical not). \&\& and $||$ are binary and left-associative. They take two operands of type bool, and return a bool value. ! is unary and appears on the left side of the operand. They type of the operand must be bool and the return type is also bool.

\subsection{Assignment Operators}
TML's assignment operator is =. it's binary and right-associative. The left operand must be an identifier and the right operand must be an expression. It assigns the value of the expression to the identifier, and returns the value of the identifier. This allows chained assignment. In addition, the following short-cut assignment operators are also defined: +=, -=, *=, /=, \%=. They require the expression and identifier of the same type.

\subsection{Parentheses}
In TML, parentheses in expressions are used to overwrite the precedence rules, Expression enclosed by the parentheses will always be calculated first before applying its adjacent operators.

\subsection{Tree Operators}
The TML is a set of operators that can be applied to trees. They are divided into three categories: tree-building, tree-copying and tree-querying.

\subsubsection{Tree-building operator}
We define $->$ to be the tree building operator. It's binary and right-associative. The left operand is a single tree node, representing the root. The right operand is a list of trees, enclosed by parentheses and seperated by commas, representing the immediate children of the root. For example, a$->$(b, c) means building a tree with a as root and b as its left subtree, and c as its right subtree. This operator returns the newly built tree.

\subsubsection{Tree-copying operators}
We define two operators to copy trees. @ means copying the node and its value only, with all of its children set to null. \$ means creating a new tree, with exactly the same stucture as the original tree. Both of them are unary and appear on the left side of the opearand. They return the new tree.

\subsubsection{Tree-querying operators}
In TML, we define operator \# as follows: \#n means the order of node n among its siblings, starting from 0. For example, if node a has three nodes b, c, d, then \#b, \#c, \#d will return 0, 1, 2, respectively. If n has no parent, \#n will return null. 

The children access operator is the square bracket. It takes a tree variable on the left side, and either an integer index or string index inside the bracket. For example, a[0] will return the first child of a if it exists, and null otherwise. Note that the operand inside the square bracket must be less than the degree of the tree. 

The dot operator will be used to access the data fields associated with the node. It's binary and left-associative. The left operand will be a tree variable, and the right operand will be one of its data fields. It will return the value of that particular field.

The ampersand (&)is used to get the degree of tree. It's unary and appears in front of a tree variable. It'll return the degree of the tree as an integer.

The ^ operator in TML is used to get the parent of the operand. It's unary and appears on the left side of the operand. It takes an expression of tree type, and returns its parent, if any. Otherwise it returns ~.

\subsection{Precedence Rules}
\begin{table}[ht]
\begin{center}
\begin{tabular}{| c | c |}
\hline
1 & () \\
2 & ., [] \\
2 & \#, & \\
3 & @, \$, ^ \\
4 & *, /, \% \\
5 & +, - \\
6 & $<$, $>$, $<=$, $>=$, $!=$, $==$ \\
7 & ! \\
8 & \&\& \\
9 & $||$ \\
10 & =, +=, -=, *=, /=, \%= \\
11 & $->$ \\
\hline
\end{tabular}
\caption{Precedence Rules}
\label{preRule}
\end {center}
\end{table}

\section{Statements}

\subsection{Variable Declarations and Initialization Statements}
Variable Declarations and Initializations are considered as statements in TML. It has the following syntax (The square brackets means optional):

\begin{code}
\begin{tabbing}
~~~~~~~~\= \textsl{type-specifier} \textsl{initializer-list}; \\
\> \textsl{initializer-list}  $\rightarrow$ \textsl{initializer} $\mid$ \textsl{initializer-list} \textsl{initializer}
\end{tabbing}
\end{code}

\subsubsection{Type Specifiers}
\label{ts}
Type Specifiers can be any basic type or user-defined tree type.

For basic types, it can be:
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item int - Intergers
\item float - Floating point numbers
\item char - Characters
\item string - Strings
\item bool - Booleans
\end{itemize}

For user-defined tree type, just write the type name identifier.

\subsubsection{Initializers}
An initializer contains two parts: the name of the variable and the initial value for it. The first part is only an identifier. The second part is optional (We use square brackets to represent optional), and contains an equal sign and an expression that will be evaluated and assigned to that variable.

\begin{code}
\begin{tabbing}
~~~~~~~~\textsl{Initializer} $\rightarrow$ identifier [= \textsl{expression}]
\end{tabbing}
\end{code}

\subsection{Expression Statements}
The expression statement is the most common one in TML. It consists of an expression and a semicolon at the end. Any expression can be used here. TML will evaluate the expression and ignore the final evaluation result.

\begin{code}
\begin{tabbing}
~~~~~~~~\textsl{expression};
\end{tabbing}
\end{code}

\subsection{Compound Statements}
The compound statement is a list of statements surrounded by curly braces.

\begin{code}
\begin{tabbing}
~~~~~~~~\{ \textsl{statement-list}
%\\
%statement
%statement
%...
%\\
\}
\end{tabbing}
\end{code}

The \textsl{statement-list} consists of sequential statements one after another

\begin{code}
\begin{tabbing}
~~~~~~~~\textsl{statement-list}  $\rightarrow$ \textsl{statement} $\mid$ \textsl{statement} \textsl{statement-list}
\end{tabbing}
\end{code}

\subsection{Conditional Statements}
The conditional statements contain only the if statement with the following syntax:

\begin{code}
\begin{tabbing}
~~~~~~~~if (\textsl{expression}) \textsl{statement} [else \textsl{statement}]
\end{tabbing}
\end{code}

If compound statements are used for both statements, as is used mostly, the if statement can be written as follows:

\begin{code}
\begin{tabbing}
%make a concrete example
~~~~~~~~\= if (x \= \textless \space 0) \\
\> \{ \\
\> \> real = false; \\
\> \> y = sqrt(-x); \\
\> \} \\
\> else \\
\> \{ \\
\> \> real = true; \\
\> \> y = sqrt(x); \\
\> \}
\end{tabbing}
\end{code}

\subsection{Iterative Statements}
There are four kinds of iterative statements: while statement, do statement, for statement and foreach statement.

\subsubsection{while statement}
The while statement contains a condition-expression and a loop body. The codes in the loop body will be executed again and again as long as the evaluation result of the condition-expression is true. The condition-expression will be evaluated before each time the loop body is executed. This statement has the following syntax:

\begin{code}
\begin{tabbing}
~~~~~~~~while (\textsl{expression}) \textsl{statement}
\end{tabbing}
\end{code}

\subsubsection{do statement}
Similar to the while statement, the do statement also contains a condition-expression and a loop body. The codes in the loop body will be executed again and again as long as the evaluation result of the condition-expression is true. But the condition-expression will be evaluated after each time the loop body is executed. This statement has the following syntax:

\begin{code}
\begin{tabbing}
~~~~~~~~\= do \= \\
\> \> \textsl{statement} \\
\> while (\textsl{expression})
\end{tabbing}
\end{code}

\subsubsection{for statement}
The for statement takes three expressions: init-expression, cond-expression and loop-expression. At the beginning, the init-expression will be evaluated. And then, the cond-expresion is evaluated repeatedly until the result is false. For each time the evaluation has the result true, the codes of the loop body will be executed and the loop-expression will be evaluated afterwards. It has the following syntax:

\begin{code}
\begin{tabbing}
~~~~~~~~\= for (\= \textsl{init-expression}; \textsl{cond-expression}; \textsl{loop-expression}) \\
\> \> \textsl{statement}
\end{tabbing}
\end{code}

\subsubsection{foreach statement}
The foreach statement is used to enumerate the elements contained in an object, like all the characters in a string, all subtrees in a tree, and so on. It is mainly operated on trees. The syntax of this statement is:

\begin{code}
\begin{tabbing}
~~~~~~~~\= forea\= ch \textsl{variable1} in \textsl{variable2} [by \textsl{function}] do \\
\> \> \textsl{statement}
\end{tabbing}
\end{code}

This statement will enumerate all the elements contained in variable2, and for each of the elements, it will store the element into variable1 and execute the loop body once. The order of the elements in each iteration will be determined by the function defined. There are four existing functions named preorder, inorder, postorder and levelorder, which are used to traverse the tree in corresponding order. If the function is not given, preorder will be used as default.

\subsection{Other Statements}
There are other statements that we may use in special conditions.

\subsubsection{break statements}
This statement is simply written as:

\begin{code}
\begin{tabbing}
~~~~~~~~break;
\end{tabbing}
\end{code}

It is used to immediately terminate a loop and execute the codes following the loop.

\subsubsection{continue statements}
This statement is simply written as:

\begin{code}
\begin{tabbing}
~~~~~~~~continue;
\end{tabbing}
\end{code}

It is used to immediately enter the next iteration of the loop ignoring the left of the codes in this iteration.

\subsubsection{return statements}
This statement is simply written as:

\begin{code}
\begin{tabbing}
~~~~~~~~return[ \textsl{expression}];
\end{tabbing}
\end{code}

It is used to immediately exit a function and take expression as the return value of the function. The expression is optional as some functions do not have a return value.

\subsubsection{NULL statements}
This statement is simply written as:

\begin{code}
\begin{tabbing}
~~~~~~~~;
\end{tabbing}
\end{code}

It does nothing.


\section{Functions}
TML allows only global functions and the functions are order-sensitive. It means that all functions should be defined outside all other function bodies, directly in the file scope. And if you want to call a function, that function should be defined before calling. It is allowed to define recursive functions, which will call the function itself inside the function body, but it is not allowed to define two functions that will call each other.

The function definition has the regular syntax as follows:
\begin{code}
\begin{tabbing}
~~~~~~~~\= \textsl{type-specifier} \textsl{identifier} ( [\textsl{parameter-list}] ) \\
\> ~~~~~~~~\textsl{statement}
\end{tabbing}
\end{code}

The type-specifier is used to declare the type of the return value of the function, and it is the same as described in section 5.1.1. The identifier is the name of the function, which is used by function calls. The statement is the function body and is usually a compound statement. What's in the parentheses is an optional parameter list with the following format and each parameter should be specified type by type-specifier and name by identifier:
\begin{code}
\begin{tabbing}
~~~~~~~~\= \textsl{parameter-list} $\rightarrow$ \= \textsl{parameter-declaration} \\
\> \> \textsl{parameter-declaration} , \textsl{parameter-list} \\
\> \textsl{parameter-declaration} $\rightarrow$ \textsl{type-specifier} \textsl{identifier}
\end{tabbing}
\end{code}

An example of function:
\begin{code}
\begin{tabbing}
~~~~~~~~\= int gcd(int a, int b) \\
\> \{ \\
\> ~~~~~~~~\= if (b $==$ 0 $||$ (a = a \% b) $==$ 0) \\
\> \> \{ \\
\> \> ~~~~~~~~\= return b; \\
\> \> \} \\
\> \> return gcd(b, a); \\
\> \}
\end{tabbing}
\end{code}

\section{Scope}
In TML, there are two finds of scopes. Codes directly written in the file has a file scope(global), starting from the current position to the end of the file. Also, each compound statement will generate a local scope confined by the two curly brackets. Identifiers can only be used within its scope.

\section{Language Restrictions}
Like various existing languages like C, Java etc, TML also has some restrictions on length of identifier names, size of basic data types, number of arguments for function calls, number of data fields in a node of type Tree and maximum degree of the node.

\section{Language Formalization}

\section{Conversions to Java}





%\begin{thebibliography}{}

%\end{thebibliography}   

\end{document}
